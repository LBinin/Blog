# 深入理解闭包及原理

## 写在最前

有几个亘古不变的问题需要梳理下：

1. 什么是闭包?
2. 闭包的原理可不可以说一下？ 
3. 你是怎样使用闭包的？

## 什么是闭包？

> 闭包是代码块和创建该代码块的上下文中数据的结合。

通过变相引用函数的活动对象导致其不能被回收，然而形成了依然可以用引用访问其作用域链的结果。

## 闭包的原理可不可以说一下？

### 词法作用域

当你编写代码时，变量和块级作用域写在哪里决定的。当词法解析器处理代码时，会保持作用域不变。（详细需看《你不知道的 JavaScript》）

### 作用域链

- 执行环境

  > 执行环境定义了变量或函数有权访问的其他数据。

  在 web 浏览器的环境栈中，全局环境（window）永远都是最外层的「执行环境」，然后在每个函数被调用的时候，**函数对应的执行环境**会被 push 到环境栈中；只有当他以及**依赖于它**的成员都执行完毕后，该环境就会被 pop 出栈。 

- 变量对象与活动对象

  **变量对象**：

  > 每个执行环境都有一个表示变量的对象，对于函数来说，这个对象里储存着在当前环境中所有的**参数**、**变量**和**函数**。它在函数执行前被创建，创建「变量对象」的过程其实就是函数内部数据（参数、变量、内部函数）的初始化过程。环境中定义的所有变量和函数都保存在这个对象里。
  > 
  > 在当前环境被执行之前， 「变量对象」中的属性都是**不可访问**的，在进入执行阶段后，「变量对象」会被转换为「活动对象」，其变得**可访问**了，然后才开始进行执行阶段的操作。

  **活动对象**：

  > 前面说到，在函数进入执行阶段后，「变量对象」会被转换为「活动对象」，所以可以把「活动对象」看成「变量对象」在真正执行时的另一种形式。
  >  
  > 这个对象里面也是包括函数内部的所有数据（参数、变量、内部函数）。

- 作用域链

  在代码在一个环境中执行的时候，会创建一个变量对象的一个作用域链。

  作用域链的前端，始终都是**当前执行**的代码所在环境的「变量对象」。全局执行环境的「变量对象」也始终都是链的最后一个对象。

  作用域链其实就是引用了**当前执行环境**的「变量对象」的指针列表，它只是引用，但不是包含。

  举个例子：
  ```js
  function foo(){
    var a = 12;
    fun(a);
    function fun(a){
      var b = 8;
      console.log(a + b);
    }
  }
  foo();
  ```

  这段代码的执行流程：

  1. 在创建 foo 的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性 `[[Scope]]` 当中。
  2. 执行 foo 函数，创建执行环境与活动对象后，取出函数的内部属性 `[[Scope]]` 构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。
  3. 执行过程中遇到了 fun，从而继续对 fun 使用上一步的操作。
  4. fun 执行结束，移出环境栈。foo 因此也执行完毕，继续移出。
  5. javscript 监听到 foo 没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。

## 面试题

```js
function fun(n,o) {
  console.log(o);
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0); a.fun(1); a.fun(2); a.fun(3); // undefined,0,0,0
var b = fun(0).fun(1).fun(2).fun(3); // undefined,0,1,2
var c = fun(0).fun(1); c.fun(2); c.fun(3); // undefined,0,1,1
```

## 总结

1. **什么是闭包？**

    > **闭包是代码块和创建该代码块的上下文中数据的结合。**

    通过变相引用函数的活动对象导致其不能被回收，然而形成了依然可以用引用访问其作用域链的结果。

2. **闭包的原理可不可以说一下？**

    结合我们上面讲过的，它的根源起始于词法阶段，在这个阶段中形成了词法作用域。最终根据调用环境产生的环境栈来形成了一个由变量对象组成的作用域链，当一个环境没有被 JS 正常垃圾回收时，我们依然可以通过引用来访问它原始的作用域链。

3. **你是怎样使用闭包的？**

    这就是智者见智了~ 比如：柯里化

## 参考资料
> [深入贯彻闭包思想，全面理解JS闭包形成过程 - Base JavaScript - SegmentFault 思否](https://segmentfault.com/a/1190000009886713)
> 
> [JavaScript内部原理系列－闭包（Closures） - kidsamong - SegmentFault 思否](https://segmentfault.com/a/1190000002452587)
